// src/server/video/caption.ts
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import OpenAI from "openai";
import { randomUUID } from "crypto";
import { spawn } from "child_process";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

const SUBS_DIR = path.join(process.cwd(), "tmp", "subs");

async function ensureDir(dir: string) {
  try {
    await fsp.mkdir(dir, { recursive: true });
  } catch {
    // ignore
  }
}

// ---- Types for Whisper verbose_json ----
type WhisperWord = {
  word: string;
  start: number;
  end: number;
};

type WhisperSegment = {
  id?: number;
  start: number;
  end: number;
  text: string;
  words?: WhisperWord[];
};

type WhisperVerboseResponse = {
  text: string;
  duration?: number;
  segments: WhisperSegment[];
};

// Helpers
function secondsToAssTime(sec: number): string {
  if (sec < 0) sec = 0;
  const hours = Math.floor(sec / 3600);
  const minutes = Math.floor((sec % 3600) / 60);
  const seconds = Math.floor(sec % 60);
  const centiseconds = Math.round((sec - Math.floor(sec)) * 100);

  const pad2 = (n: number) => n.toString().padStart(2, "0");
  const pad2c = (n: number) => n.toString().padStart(2, "0");

  return `${hours}:${pad2(minutes)}:${pad2(seconds)}.${pad2c(centiseconds)}`;
}

type CaptionStyle = "boldYellow" | "subtle" | "karaoke";

const DEFAULT_FONT = "Inter"; // you‚Äôll ship this font in public/fonts

// ===== Premium styling knobs (SAFE) =====
const CHUNK_SIZE = 4;

// Fade is subtle; remove if you want it 100% static
const LINE_FADE_IN_MS = 40;
const LINE_FADE_OUT_MS = 80;

// Karaoke ‚Äúcurrent word pop‚Äù
const KARAOKE_POP_SCALE = 118; // 112‚Äì122 usually looks best
const KARAOKE_POP_IN_MS = 70; // how fast it pops in
const KARAOKE_POP_OUT_MS = 80; // how fast it returns

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function buildAssHeader(style: CaptionStyle, fontName = DEFAULT_FONT): string {
  // 1080x1920 for vertical
  const playResX = 1080;
  const playResY = 1920;

  const styleLine = buildAssStyleLine(style, fontName);

  return `[Script Info]
; Script generated by Hookify
ScriptType: v4.00+
PlayResX: ${playResX}
PlayResY: ${playResY}
WrapStyle: 2
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${styleLine}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
}

function buildAssStyleLine(style: CaptionStyle, fontName: string): string {
  // NOTE: ASS color order is &HAABBGGRR&
  // PrimaryColour is the base text. SecondaryColour is used by karaoke fills.
  const base = {
    Name: "Default",
    Fontname: fontName,
    Fontsize: 56,
    PrimaryColour: "&H00FFFFFF&",
    SecondaryColour: "&H00FFFFFF&",
    OutlineColour: "&HAA000000&",
    BackColour: "&H00000000&",
    Bold: 1,
    Italic: 0,
    Underline: 0,
    StrikeOut: 0,
    ScaleX: 100,
    ScaleY: 100,
    Spacing: 0,
    Angle: 0,
    BorderStyle: 1,
    Outline: 4,
    Shadow: 2,
    Alignment: 2,
    MarginL: 80,
    MarginR: 80,
    MarginV: 120,
    Encoding: 1,
  };

  if (style === "subtle") {
    // Clean + readable + low noise
    return (
      "Style: " +
      [
        base.Name,
        base.Fontname,
        52,
        "&H00FFFFFF&", // white
        "&H00FFFFFF&",
        "&H99000000&", // softer outline
        "&H00000000&",
        0,
        0,
        0,
        0, // Bold off
        base.ScaleX,
        base.ScaleY,
        0,
        0,
        1,
        3, // Outline
        2, // Shadow
        2,
        base.MarginL,
        base.MarginR,
        130,
        base.Encoding,
      ].join(",")
    );
  }

  if (style === "boldYellow") {
    // ‚ÄúShorts‚Äù look: bigger, bold, strong outline & shadow
    return (
      "Style: " +
      [
        base.Name,
        base.Fontname,
        64, // bigger
        "&H0000FFFF&", // yellow
        "&H00FFFFFF&",
        "&HEE000000&", // strong outline
        "&H00000000&",
        1,
        0,
        0,
        0, // Bold on
        base.ScaleX,
        base.ScaleY,
        0,
        0,
        1,
        7, // thicker outline
        4, // stronger shadow
        2,
        base.MarginL,
        base.MarginR,
        120,
        base.Encoding,
      ].join(",")
    );
  }

  // karaoke
  // base white + karaoke fill yellow, clean outline, small shadow
  return (
    "Style: " +
    [
      "Default",
      fontName,
      62, // a bit bigger
      "&H00FFFFFF&", // white
      "&H00FFD200&", // yellow fill (your original)
      "&HDD000000&", // outline
      "&H00000000&",
      1,
      0,
      0,
      0,
      100,
      100,
      0,
      0,
      1,
      4, // slightly thicker outline
      2, // shadow for readability
      2,
      80,
      80,
      120,
      1,
    ].join(",")
  );
}

/**
 * If Whisper didn't give us word-level timestamps,
 * fabricate them evenly across the segment.
 */
function synthesizeWordsFromSegment(seg: WhisperSegment): WhisperWord[] {
  const raw = (seg.text || "").replace(/\s+/g, " ").trim();
  if (!raw) return [];

  const tokens = raw.split(" ").filter(Boolean);
  if (!tokens.length) return [];

  const totalDur = Math.max(seg.end - seg.start, 0.5);
  const perWord = totalDur / tokens.length;

  const words: WhisperWord[] = [];
  let cursor = seg.start;

  for (const token of tokens) {
    const start = cursor;
    const end = cursor + perWord;
    words.push({ word: token, start, end });
    cursor = end;
  }

  return words;
}

function safeAssText(raw: string): string {
  // Keep it light; do NOT escape backslashes because karaoke tags rely on them.
  // Only normalize whitespace/newlines.
  return (raw ?? "").replace(/\r?\n/g, "\\N").replace(/\s+/g, " ").trim();
}

async function runCmd(cmd: string, args: string[], logPrefix: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const proc = spawn(cmd, args);
    let stderr = "";

    proc.stderr.on("data", (d) => (stderr += d.toString()));
    proc.on("error", reject);

    proc.on("close", (code) => {
      if (code === 0) resolve();
      else reject(new Error(`[${logPrefix}] ${cmd} exited with ${code}\n${stderr}`));
    });
  });
}

async function extractTinyAudioForWhisper(videoPath: string): Promise<string> {
  const AUDIO_DIR = path.join(process.cwd(), "tmp", "audio");
  await ensureDir(AUDIO_DIR);

  const outPath = path.join(AUDIO_DIR, `${randomUUID()}.mp3`);

  // IMPORTANT: mono + 16k + low bitrate => stays under 25MB
  const args = [
    "-y",
    "-i",
    videoPath,
    "-map",
    "0:a:0?",
    "-vn",
    "-ac",
    "1",
    "-ar",
    "16000",
    "-c:a",
    "libmp3lame",
    "-b:a",
    "24k", // üëà safe; po»õi urca la 32k dacƒÉ vrei, dar 24k e cel mai ‚Äúsafe‚Äù
    outPath,
  ];

  await runCmd("ffmpeg", args, "extractTinyAudioForWhisper");
  await fsp.access(outPath);

  // Guard: OpenAI limit ~25MB => keep some headroom
  const stat = await fsp.stat(outPath);

  if (stat.size < 1024) {
    throw new Error("No audio track or extracted audio too small for Whisper");
  }

  const MAX_BYTES = 24 * 1024 * 1024;

  if (stat.size > MAX_BYTES) {
    // DacƒÉ tot e mare, mai √ÆncearcƒÉ o datƒÉ »ôi mai mic
    const outPath2 = path.join(AUDIO_DIR, `${randomUUID()}.mp3`);
    const args2 = [
      "-y",
      "-i",
      videoPath,
      "-map",
      "0:a:0?",
      "-vn",
      "-ac",
      "1",
      "-ar",
      "16000",
      "-c:a",
      "libmp3lame",
      "-b:a",
      "16k",
      outPath2,
    ];
    await runCmd("ffmpeg", args2, "extractTinyAudioForWhisper_16k");
    await fsp.access(outPath2);
    await fsp.unlink(outPath).catch(() => {});
    return outPath2;
  }

  return outPath;
}

/**
 * Build karaoke text (\k tags) for a small group of words.
 * PREMIUM: "current word pop" using \t transforms on the word's time range.
 * This DOES NOT change word order or text ‚Äî only adds styling tags.
 */
function buildKaraokeForChunk(words: WhisperWord[]): string {
  let assText = "";
  let cursorMs = 0; // relative timeline inside this Dialogue line

  for (const w of words) {
    const rawWord = safeAssText(w.word || "");
    if (!rawWord) continue;

    const durSec = Math.max(0.03, w.end - w.start);
    const durCs = Math.max(1, Math.round(durSec * 100)); // karaoke uses centiseconds
    const durMs = durCs * 10;

    const wordStartMs = cursorMs;
    const wordEndMs = cursorMs + durMs;

    // Ensure transform windows make sense even for very short words
    const popInEnd = Math.min(wordStartMs + KARAOKE_POP_IN_MS, wordEndMs);
    const popOutStart = Math.max(wordEndMs - KARAOKE_POP_OUT_MS, wordStartMs);

    const popScale = clamp(KARAOKE_POP_SCALE, 105, 140);

    if (assText) assText += " ";

    // We keep \k EXACT. We add transforms for just this word:
    // - Pop in early, pop out near the end of that word.
    // Tags scope to subsequent text, so we reset scale immediately after the word.
    assText +=
      `{\\k${durCs}}` +
      `{\\t(${wordStartMs},${popInEnd},\\fscx${popScale}\\fscy${popScale})` +
      `\\t(${popOutStart},${wordEndMs},\\fscx100\\fscy100)}` +
      `${rawWord}` +
      `{\\fscx100\\fscy100}`;

    cursorMs += durMs;
  }

  return assText.trim();
}

/**
 * Split the segment into multiple chunks (max 4 words per chunk),
 * each with its own time window [start, end] based on word timestamps.
 */
function buildKaraokeChunksFromSegment(
  seg: WhisperSegment,
): { start: number; end: number; text: string }[] {
  const words = seg.words && seg.words.length > 0 ? seg.words : synthesizeWordsFromSegment(seg);
  if (!words.length) return [];

  const chunks: { start: number; end: number; text: string }[] = [];

  for (let i = 0; i < words.length; i += CHUNK_SIZE) {
    const group = words.slice(i, i + CHUNK_SIZE);
    if (!group.length) continue;

    const start = group[0].start;
    const end = group[group.length - 1].end;
    const text = buildKaraokeForChunk(group);

    if (!text.trim()) continue;
    chunks.push({ start, end, text });
  }

  return chunks;
}

function buildPlainChunksFromSegment(
  seg: WhisperSegment,
): { start: number; end: number; text: string }[] {
  const words = seg.words?.length ? seg.words : synthesizeWordsFromSegment(seg);
  if (!words.length) return [];

  const chunks: { start: number; end: number; text: string }[] = [];

  for (let i = 0; i < words.length; i += CHUNK_SIZE) {
    const group = words.slice(i, i + CHUNK_SIZE);
    const start = group[0].start;
    const end = group[group.length - 1].end;
    const text = group
      .map((w) => safeAssText(w.word || ""))
      .filter(Boolean)
      .join(" ");
    if (text) chunks.push({ start, end, text });
  }

  return chunks;
}

function applyInlineStyle(text: string, style: CaptionStyle) {
  // IMPORTANT: only visuals; don't change wording.
  // Avoid "reset to white" at the end ‚Äî it can cause weirdness across renderers.
  if (style === "boldYellow") {
    // extra punch: thick outline/shadow + keep yellow
    return `{\\b1\\bord7\\shad4\\c&H0000FFFF&}${text}`;
  }
  if (style === "subtle") {
    // clean white with soft outline/shadow
    return `{\\b0\\bord3\\shad2\\c&H00FFFFFF&}${text}`;
  }
  return text; // karaoke already contains \k + transforms
}

function lineFade(): string {
  // subtle, safe ‚Äúpremium‚Äù motion
  return `{\\fad(${LINE_FADE_IN_MS},${LINE_FADE_OUT_MS})}`;
}

/**
 * Transcribe a clip and save a karaoke-style ASS file
 * with small 3‚Äì4 word chunks instead of big paragraphs.
 */
export async function transcribeClipToAss(
  clipPath: string,
  outAssPath: string,
  captionStyle: CaptionStyle = "karaoke",
  fontName: string = DEFAULT_FONT,
): Promise<string> {
  await ensureDir(SUBS_DIR);

  const audioPath = await extractTinyAudioForWhisper(clipPath);

  try {
    const resp = (await openai.audio.transcriptions.create({
      model: "whisper-1",
      file: fs.createReadStream(audioPath),
      response_format: "verbose_json",
      timestamp_granularities: ["word", "segment"],
    })) as unknown as WhisperVerboseResponse;

    if (!resp.segments || resp.segments.length === 0) {
      console.warn(
        "[transcribeClipToAss] No segments returned ‚Äì writing empty ASS with header only",
      );
      await fsp.writeFile(outAssPath, buildAssHeader(captionStyle, fontName), "utf8");
      return outAssPath;
    }

    console.log("[transcribeClipToAss] Segments count:", resp.segments.length);

    let ass = buildAssHeader(captionStyle, fontName);

    for (const seg of resp.segments) {
      const chunks =
        captionStyle === "karaoke"
          ? buildKaraokeChunksFromSegment(seg)
          : buildPlainChunksFromSegment(seg);

      if (!chunks.length) continue;

      for (const chunk of chunks) {
        const start = secondsToAssTime(chunk.start);
        const end = secondsToAssTime(chunk.end);

        const baseText = safeAssText(chunk.text);

        const styledText =
          captionStyle === "karaoke"
            ? baseText // already has tags + transforms
            : applyInlineStyle(baseText, captionStyle);

        const text = `${lineFade()}${styledText}`;

        const dialogue = ["Dialogue: 0", start, end, "Default", "", "0", "0", "0", "", text].join(
          ",",
        );
        ass += dialogue + "\n";
      }
    }

    await fsp.writeFile(outAssPath, ass, "utf8");
    console.log("[transcribeClipToAss] Wrote ASS:", outAssPath);
    return outAssPath;
  } catch (err) {
    console.error("[transcribeClipToAss] Error:", err);

    await ensureDir(path.dirname(outAssPath));
    await fsp.writeFile(outAssPath, buildAssHeader(captionStyle, fontName), "utf8");
    console.log("[transcribeClipToAss] Wrote empty ASS fallback:", outAssPath);
    return outAssPath;
  } finally {
    await fsp.unlink(audioPath).catch(() => {});
  }
}

/**
 * Generate subtitle files (ASS) for all clips.
 */
export async function generateSubtitlesForClips(
  clips: string[],
  options?: { captionStyle?: CaptionStyle; fontName?: string },
): Promise<string[]> {
  await ensureDir(SUBS_DIR);

  const captionStyle = options?.captionStyle ?? "karaoke";
  const fontName = options?.fontName ?? DEFAULT_FONT;

  const subtitleFiles: string[] = [];

  for (const clipPath of clips) {
    const base = path.basename(clipPath, path.extname(clipPath));
    const assPath = path.join(SUBS_DIR, `${base}.ass`);
    const outPath = await transcribeClipToAss(clipPath, assPath, captionStyle, fontName);
    subtitleFiles.push(outPath);
  }

  return subtitleFiles;
}
