// src/server/video/caption.ts
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import OpenAI from "openai";

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY!,
});

const SUBS_DIR = path.join(process.cwd(), "tmp", "subs");

async function ensureDir(dir: string) {
    try {
        await fsp.mkdir(dir, { recursive: true });
    } catch {
        // ignore
    }
}

// ---- Types for Whisper verbose_json ----
type WhisperWord = {
    word: string;
    start: number;
    end: number;
};

type WhisperSegment = {
    id?: number;
    start: number;
    end: number;
    text: string;
    words?: WhisperWord[];
};

type WhisperVerboseResponse = {
    text: string;
    duration?: number;
    segments: WhisperSegment[];
};

// Helpers
function secondsToAssTime(sec: number): string {
    if (sec < 0) sec = 0;
    const hours = Math.floor(sec / 3600);
    const minutes = Math.floor((sec % 3600) / 60);
    const seconds = Math.floor(sec % 60);
    const centiseconds = Math.round((sec - Math.floor(sec)) * 100);

    const pad2 = (n: number) => n.toString().padStart(2, "0");
    const pad2c = (n: number) => n.toString().padStart(2, "0");

    return `${hours}:${pad2(minutes)}:${pad2(seconds)}.${pad2c(centiseconds)}`;
}

type CaptionStyle = "boldYellow" | "subtle" | "karaoke";

const DEFAULT_FONT = "Inter"; // you’ll ship this font in public/fonts

function buildAssHeader(style: CaptionStyle, fontName = DEFAULT_FONT): string {
    // 1080x1920 for vertical; if you render horizontal too, pass these in.
    const playResX = 1080;
    const playResY = 1920;

    const styleLine = buildAssStyleLine(style, fontName);

    return `[Script Info]
; Script generated by Hookify
ScriptType: v4.00+
PlayResX: ${playResX}
PlayResY: ${playResY}
WrapStyle: 2
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${styleLine}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
}

function buildAssStyleLine(style: CaptionStyle, fontName: string): string {
    const base = {
        Name: "Default",
        Fontname: fontName,
        Fontsize: 56,
        PrimaryColour: "&H00FFFFFF&",
        SecondaryColour: "&H00FFFFFF&",
        OutlineColour: "&HAA000000&",
        BackColour: "&H55000000&",
        Bold: 1,
        Italic: 0,
        Underline: 0,
        StrikeOut: 0,
        ScaleX: 100,
        ScaleY: 100,
        Spacing: 0,
        Angle: 0,
        BorderStyle: 1,
        Outline: 4,
        Shadow: 0,
        Alignment: 2,
        MarginL: 80,
        MarginR: 80,
        MarginV: 120,
        Encoding: 1,
    };

    if (style === "subtle") {
        return (
            "Style: " +
            [
                base.Name,
                base.Fontname,
                52,
                "&H00FFFFFF&",
                "&H00FFFFFF&",
                "&H88000000&",
                "&H00000000&",
                0, 0, 0, 0,
                base.ScaleX, base.ScaleY, 0, 0,
                1, 3, 1, 2,
                base.MarginL, base.MarginR, 130,
                base.Encoding,
            ].join(",")
        );
    }

    if (style === "boldYellow") {
        return (
            "Style: " +
            [
                base.Name,
                base.Fontname,
                60,
                "&H0000FFFF&",
                "&H00FFFFFF&",
                "&HCC000000&",
                "&H00000000&",
                1, 0, 0, 0,
                base.ScaleX, base.ScaleY, 0, 0,
                1, 6, 0, 2,
                base.MarginL, base.MarginR, 120,
                base.Encoding,
            ].join(",")
        );
    }

    // karaoke

    return (
        "Style: " +
        [
            "Default",
            fontName,
            60,
            "&H00FFFFFF&",   // white
            "&H00FFD200&",   // yellow karaoke fill
            "&HCC000000&",   // outline color (black)
            "&H00000000&",   // no box
            1,0,0,0,
            100,100,0,0,
            1,               // BorderStyle=1 => outline
            2,               // Outline=2 (clean)
            0,               // Shadow=0
            2,
            80,80,120,
            1
        ].join(",")
    );
}


/**
 * If Whisper didn't give us word-level timestamps,
 * fabricate them evenly across the segment.
 */
function synthesizeWordsFromSegment(seg: WhisperSegment): WhisperWord[] {
    const raw = (seg.text || "").replace(/\s+/g, " ").trim();
    if (!raw) return [];

    const tokens = raw.split(" ").filter(Boolean);
    if (!tokens.length) return [];

    const totalDur = Math.max(seg.end - seg.start, 0.5);
    const perWord = totalDur / tokens.length;

    const words: WhisperWord[] = [];
    let cursor = seg.start;

    for (const token of tokens) {
        const start = cursor;
        const end = cursor + perWord;
        words.push({ word: token, start, end });
        cursor = end;
    }

    return words;
}

/**
 * Build karaoke text (\k tags) for a small group of words.
 * This is for a *chunk*, not the whole segment.
 */
function buildKaraokeForChunk(words: WhisperWord[]): string {
    let assText = "";

    for (const w of words) {
        const raw = (w.word || "").replace(/\s+/g, " ").trim();
        if (!raw) continue;

        const durSec = Math.max(0.03, w.end - w.start);
        const durCs = Math.max(1, Math.round(durSec * 100));

        if (assText) {
            assText += " ";
        }

        assText += `{\\k${durCs}}${raw}`;
    }

    return assText.trim();
}

/**
 * Split the segment into multiple chunks (max 4 words per chunk),
 * each with its own time window [start, end] based on word timestamps.
 */
function buildKaraokeChunksFromSegment(seg: WhisperSegment): {
    start: number;
    end: number;
    text: string;
}[] {
    const CHUNK_SIZE = 4;

    const words =
        seg.words && seg.words.length > 0
            ? seg.words
            : synthesizeWordsFromSegment(seg);

    if (!words.length) return [];

    const chunks: { start: number; end: number; text: string }[] = [];

    for (let i = 0; i < words.length; i += CHUNK_SIZE) {
        const group = words.slice(i, i + CHUNK_SIZE);
        if (!group.length) continue;

        const start = group[0].start;
        const end = group[group.length - 1].end;
        const text = buildKaraokeForChunk(group);

        if (!text.trim()) continue;

        chunks.push({ start, end, text });
    }

    return chunks;
}

function buildPlainChunksFromSegment(seg: WhisperSegment): { start: number; end: number; text: string }[] {
    const words = seg.words?.length ? seg.words : synthesizeWordsFromSegment(seg);
    if (!words.length) return [];

    const CHUNK_SIZE = 4;
    const chunks: { start: number; end: number; text: string }[] = [];

    for (let i = 0; i < words.length; i += CHUNK_SIZE) {
        const group = words.slice(i, i + CHUNK_SIZE);
        const start = group[0].start;
        const end = group[group.length - 1].end;
        const text = group.map(w => (w.word || "").trim()).filter(Boolean).join(" ");
        if (text) chunks.push({ start, end, text });
    }

    return chunks;
}

function applyInlineStyle(text: string, style: CaptionStyle) {
    if (style === "boldYellow") {
        return `{\\b1\\c&H0000FFFF&}${text}{\\b0\\c&H00FFFFFF&}`;
    }
    if (style === "subtle") {
        return `{\\b0\\c&H00FFFFFF&}${text}`;
    }
    return text; // karaoke already contains \k tags
}

/**
 * Transcribe a clip and save a karaoke-style ASS file
 * with small 3–4 word chunks instead of big paragraphs.
 */
export async function transcribeClipToAss(
    clipPath: string,
    outAssPath: string,
    captionStyle: CaptionStyle = "karaoke",
    fontName: string = DEFAULT_FONT
): Promise<string> {
    await ensureDir(SUBS_DIR);

    try {
        const resp = (await openai.audio.transcriptions.create({
            model: "whisper-1",
            file: fs.createReadStream(clipPath),
            response_format: "verbose_json",
            timestamp_granularities: ["word", "segment"],
        })) as unknown as WhisperVerboseResponse;

        if (!resp.segments || resp.segments.length === 0) {
            console.warn(
                "[transcribeClipToAss] No segments returned – writing empty ASS with header only"
            );
            await fsp.writeFile(outAssPath, buildAssHeader(captionStyle, fontName), "utf8");
            return outAssPath;
        }

        console.log(
            "[transcribeClipToAss] Segments count:",
            resp.segments.length
        );

        let ass = buildAssHeader(captionStyle, fontName);

        for (const seg of resp.segments) {
            // const chunks = buildKaraokeChunksFromSegment(seg);
            const chunks =
                captionStyle === "karaoke"
                    ? buildKaraokeChunksFromSegment(seg)
                    : buildPlainChunksFromSegment(seg);

            if (!chunks.length) continue;

            for (const chunk of chunks) {
                const start = secondsToAssTime(chunk.start);
                const end = secondsToAssTime(chunk.end);

                const text =
                    captionStyle === "karaoke"
                        ? chunk.text.replace(/\n/g, "\\N")
                        : applyInlineStyle(chunk.text.replace(/\n/g, "\\N"), captionStyle);

                const dialogue = [
                    "Dialogue: 0",
                    start,
                    end,
                    "Default",
                    "",
                    "0",
                    "0",
                    "0",
                    "",
                    text,
                ].join(",");

                ass += dialogue + "\n";
            }
        }

        await fsp.writeFile(outAssPath, ass, "utf8");
        console.log("[transcribeClipToAss] Wrote ASS:", outAssPath);
        return outAssPath;
    } catch (err) {
        console.error("[transcribeClipToAss] Error:", err);

        await ensureDir(path.dirname(outAssPath));
        await fsp.writeFile(outAssPath, buildAssHeader(captionStyle, fontName), "utf8");
        console.log(
            "[transcribeClipToAss] Wrote empty ASS fallback:",
            outAssPath
        );
        return outAssPath;
    }
}

/**
 * Generate subtitle files (ASS) for all clips.
 */
export async function generateSubtitlesForClips(
    clips: string[],
    options?: { captionStyle?: CaptionStyle; fontName?: string }
): Promise<string[]> {
    await ensureDir(SUBS_DIR);

    const captionStyle = options?.captionStyle ?? "karaoke";
    const fontName = options?.fontName ?? DEFAULT_FONT;

    const subtitleFiles: string[] = [];

    for (const clipPath of clips) {
        const base = path.basename(clipPath, path.extname(clipPath));
        const assPath = path.join(SUBS_DIR, `${base}.ass`);
        const outPath = await transcribeClipToAss(clipPath, assPath, captionStyle, fontName);
        subtitleFiles.push(outPath);
    }

    return subtitleFiles;
}
